pragma solidity 0.4.24;

import "./Ownable.sol";

/// @title A survey smart contract
/// @author Anson Lau
/// @notice You can use this contract for creating simple questionnaire and reward Ether to the participants
/// Those questions & answers is stored in IPFS

contract Survey is Ownable {
    /// @dev This emits when create questionnaire is created
    event LogCreateQuestionnaire(address indexed creator, bytes32 key); 
    
    /// @dev This emits when response is submitted
    event LogSubmitResponse(address indexed sender, string responseIpfsHash);
    
    /// @dev This emits when the participant claim reward
    event LogClaimReward(address indexed sender, uint256 indexed rewards);
    
    // Keep all questionnaires
    bytes32 [] public questionnaires;
    
    // Status of the current contract 
    bool public contractStopped = false;
    
    // Mapping of questionnaire key to questionnaire
    mapping (bytes32 => Questionnaire) public questionnaireStruct;
    
    // Mapping of questionnaire key and sender address to the Response struct 
    // This enables use questionnaire[key][senderAddress] to retrieve the Response struct
    mapping (bytes32 => mapping (address => Response)) private responseStruct;

    // Questionnaire data structure
    struct Questionnaire {
        address creator;
        string questionIpfsHash; 
        uint256 maxParticipants;
        uint256 actualParticipants;
        uint256 rewards;            // Reward in ETH
        bool isCompleted;
        uint256 numOfRewardClaimed;
        Response[] responses;       // Participants response
    }
    
    // Participant data structure
    struct Response {
        address sender;
        string responseIpfsHash;    
        bool isRewardClaimed;       // True or False
    }

    // Used to check contract status before executing createQuestionnaire function
    modifier haltInEmergency {
        require(!contractStopped);
        _;
    }
    
    /// @notice only the contract owner is allowed to change
    /// @dev change the contract status to pause or continue
    function toggleContractStopped() public onlyOwner {
        contractStopped = !contractStopped;
    }

    /// @dev create a new questionnaire
    /// @param questionnaireKey The key of questionnaire (Generated by using hash function)
    /// @param questionHash The unique IPFS hash to represent the list of questions
    /// @param maxParticipants The number of people can submit their responses
    /// @return True if the questionnaire is successfully created
     // Need questionnaire title ???
    function createQuestionnaire(bytes32 questionnaireKey, string questionHash, uint256 maxParticipants) public haltInEmergency payable returns (bool) {
        // Validate reward & max participants are greater than 0
        require(msg.value > 0, "Reward less than 0");
        require(maxParticipants > 0, "Max Participants less than 0");
        // Validate questionHash is not empty
        bytes memory emptyHashTest = bytes(questionHash); // Uses memory
        require(emptyHashTest.length != 0, "IPFS hash is empty");
        // Initialize the questionnaire
        questionnaireStruct[questionnaireKey].creator = msg.sender;
        questionnaireStruct[questionnaireKey].questionIpfsHash = questionHash;
        questionnaireStruct[questionnaireKey].maxParticipants = maxParticipants;
        questionnaireStruct[questionnaireKey].actualParticipants = 0;
        questionnaireStruct[questionnaireKey].rewards = msg.value;
        questionnaireStruct[questionnaireKey].isCompleted = false;
        questionnaireStruct[questionnaireKey].numOfRewardClaimed = 0;
        questionnaires.push(questionnaireKey);

        emit LogCreateQuestionnaire(msg.sender, questionnaireKey);
        return true;
    }

    /// @dev participant submit a response to the questionnaire
    /// @param questionnaireKey The key of questionnaire
    /// @param responseHash The unique IPFS hash to represent the answers
    /// @return True if the response is successfully submitted
    function submitResponse(bytes32 questionnaireKey, string responseHash) public returns (bool) {
        Questionnaire storage questionnaire = questionnaireStruct[questionnaireKey];        
        // Validate questionnaire status
        require(!questionnaire.isCompleted, "Questionnaire is completed.");
        // Validate actualParticipants < maxParticipants
        require(questionnaire.actualParticipants < questionnaire.maxParticipants, "Max participants are reached already.");
        // Validate sender has not responsed to the questionnaire before
        require(responseStruct[questionnaireKey][msg.sender].sender == address(0), "You have done before.");
        // Push the Response to the questionnaire & update actualParticipants
        Response memory response = Response(msg.sender, responseHash, false);
        questionnaire.responses.push(response);
        questionnaire.actualParticipants += 1;
        // Assign the response to a specific questionnaireKey & sender for searching
        responseStruct[questionnaireKey][msg.sender] = response;
        // Check if the max participants are reached
        if (questionnaire.actualParticipants == questionnaire.maxParticipants) {
            questionnaire.isCompleted = true;
        }

        emit LogSubmitResponse(msg.sender, responseHash);
        return true;    
    }

    /// @dev participant can cliam his/her reward when the questionnaire is completed
    /// @param questionnaireKey The key of questionnaire
    /// @return True if the reward claim is succeed and transfer the reward to the sender
    function cliamRewards(bytes32 questionnaireKey) public returns (bool) {
        Questionnaire storage questionnaire = questionnaireStruct[questionnaireKey];
        // Validate questionnaire status 
        require(questionnaire.isCompleted, "Max participants is not reached yet.");
        // Validate the number of reward claim is still available
        require(questionnaire.numOfRewardClaimed < questionnaire.actualParticipants, "The Max of the number of reward can be claimed already reached.");
        // Validate the sender reward claim status
        require(!responseStruct[questionnaireKey][msg.sender].isRewardClaimed, "Sender already cliamed his/her reward.");
        // Validate the sender has submitted a response
        require(responseStruct[questionnaireKey][msg.sender].sender > 0, "Sender does not have participated the questionnaire.");
        // Calculate the indvidual reward by dividing actualParticipants / rewards
        uint individualRewardAllocation = questionnaire.rewards / questionnaire.actualParticipants;
        // Validate the contract has enough balance
        require(balance() >= individualRewardAllocation, "Contract does not have enough balance.");
        // Update the rewardClaim & number of rewardCliamed
        Response storage response = responseStruct[questionnaireKey][msg.sender];
        response.isRewardClaimed = true;
        questionnaire.numOfRewardClaimed += 1;
        // Transfer reward to the sender
        msg.sender.transfer(individualRewardAllocation);
        emit LogClaimReward(msg.sender, individualRewardAllocation);
        return true;
    }

    /// @notice When you create a questionnaire and set Max particpants
    ///         to 100 and after some time that still has not reached the target
    ///         then the creator can mannully change the status to COMPLETED for
    ///         particpants to cliam their rewards
    /// @dev Change the questionnaire status to COMPLETED manually
    /// @param questionnaireKey The key of questionnaire
    /// @param isCompleted Current status of the questionnaire
    /// @return True if the questionnaire status is updated to true 
    function setQuestionnaireStatus(bytes32 questionnaireKey, bool isCompleted) public returns (bool) {
        Questionnaire storage questionnaire = questionnaireStruct[questionnaireKey];
        // Validate questionnaire status
        require(!isCompleted);
        questionnaire.isCompleted = isCompleted;
        return true;
    }

    /// @return the contract balance
    function balance() public view returns (uint256) {
        return address(this).balance;
    }

    /// @dev get the number of responses for a particular questionnaire
    /// @param questionnaireKey The key of questionnaire
    /// @return the total number of responses for a specific questionnaire
    function getQuestionnairesCount(bytes32 questionnaireKey) public view returns (uint) {
        return questionnaireStruct[questionnaireKey].responses.length;
    }
    
    /// @return all questionnaires keys
    function getAllQuestionnaires() external view returns (bytes32[]) {
        return questionnaires;    
    }
    
    /// @dev get a specific location response by providing key & index
    /// @param questionnaireKey The key of questionnaire
    /// @param index The specific position of the Responses array
    function getQuestionnairesResponse(bytes32 questionnaireKey, uint256 index) external view returns (address, string) {
        Response memory response = questionnaireStruct[questionnaireKey].responses[index];
        return (response.sender, response.responseIpfsHash);
    }
}